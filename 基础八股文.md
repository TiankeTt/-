# 前端八股文

## 基础篇

1. ### 数据类型

   1. #### 基本类型

      **存储在栈中，在栈中存放的是对应的值**

      - Number
      - String
      - Boolean
      - undefined
      - null
      - symbol
        使用 symbol 可以从根本上避免这种冲突，因为每个 Symbol 值都是唯一的，即使描述（description）相同也是此。例如多团队开发，给同一个对象增加属性

        ```javascript
        const obj = {};
        /** 团队A */
        const teamA = Symbol("描述");
        obj[teamA] = "我是团队A";
        /** 团队B */
        const teamB = Symbol("描述");
        obj[teamB] = "我是团队B";

        console.log(obj); // {Symbol(描述): '我是团队A', Symbol(描述): '我是团队B'}
        console.log(obj[teamA]); // '我是团队A'
        console.log(obj[teamB]); // '我是团队B'
        ```

      - 检测方法：typeof、Object.prototype.toString.call()

   2. #### 复杂类型

      **(复杂类型统称为 Object， 其他还有 Date、RegExp、 Map、 Set), 引用类型存储在堆内存（栈中存储指针地址）**

      > 变量赋值，将保存对象的内存地址赋值给另一个变量。也就是俩个变量指向堆内存中同一个对象

      - Object (对象和数组)
      - Function

        1. Function 是一个构造函数

           - Function 是 JavaScript 中的一个内置构造函数，用于创建新的函数对象。
           - 当你使用函数声明、函数表达式或构造函数 new Function 创建一个函数时，这个函数实际上是 Function 构造函数的实例。

             ```javascript
             const funA = () => {
               console.log("aaa");
             };
             const newFunA = new Function("console.log('aaa');");
             // 俩函数执行后的打印的效果是一样的
             ```

        2. 函数是 Function 的实例

           - 通过 instanceof 操作符可以验证一个函数是否是 Function 的实例。

             ```javascript
             const funA = () => {
               console.log("aaa");
             };
             // 函数对象的原型
             Function.prototype === funA.__proto__; // true
             ```

        3. Function 的方法（call、apply、bind）

           - call 和 apply 是声明后立即执行，二者都是调用一个函数，并将函数内的 this 指向特定的对象，区别是传参 apply 接受一个参数数组。
           - bind 创建一个新的函数，该函数的 this 被绑定到指定的对象

             ```javascript
             const obj = {
               name: "John",
             };

             function sayHello(greeting) {
               console.log(`${greeting}, ${this.name}!`);
             }
             sayHello.call(obj, "Hello"); // Hello, John!
             sayHello.apply(obj, ["Hi"]); // Hi, John!

             const sayHelloBound = sayHello.bind(obj);
             sayHelloBound("Good morning"); // Good morning, John!
             ```

      - 检测方法：instanceof Object.prototype.toString.call()

2. ### 内置数据结构

   1. #### 数组（Array）

      - 作用：存储有序集合，支持动态增删元素。
      - 需掌握：

        - 常用方法（push、pop、splice、map、filter 等）。
        - 稀疏数组

          **定义**：
          **稀疏数组是指数组中存在大量“空位”的数组，即某些索引位置未被赋值或显式赋值为 empty。**

          - 特点：

            - 内存占用更小（空位不分配内存）。
            - 遍历时可能跳过空位（如 forEach、map 等方法）。
            - 空位值为 undefined（但不等同于显式赋值为 undefined）。

          **创建稀疏数组的方式**

          1. 直接设置长度：

             ```javascript
             const sparseArr = new Array(5); // 创建长度为5的空数组
             console.log(sparseArr); // [empty × 5]
             ```

          2. 跳过索引赋值：

             ```javascript
             const arr = [];
             arr[0] = 1;
             arr[100] = 5;
             console.log(arr); // [1, empty × 99, 5]
             ```

          **稀疏数组的检测与操作**

          1. 检测空位：

             ```javascript
             // 检测索引2是否为空位
             console.log(2 in arr); // false（未被赋值）
             ```

          2. 遍历时的行为：

             ```javascript
             const sparseArr = [1, , 3]; // 中间是空位
             sparseArr.forEach((item, index) => {
               console.log(index); // 输出 0, 2（跳过空位）
             });
             ```

          **应用场景**

          - 节省内存：处理大规模数据时，若大部分位置无需存储值（如稀疏矩阵）。
          - 动态占位：需要预留位置但暂不赋值的场景（如游戏地图初始化）。

        - 多维数组

        - 如何判断数组
          - Array.isArray()
          - Object.prototype.toString.call()

   2. #### 对象（Object）

      - 作用：键值对集合，用于描述复杂实体。
      - Map 与普通对象的区别

        1. 键的类型

           - Map：键可以是任意类型（对象、函数、原始值等）。
           - 普通对象：键只能是字符串或 Symbol，其他类型会被隐式转换为字符串（如 {} 作为键会被转成 "[object Object]"）。

           ```javascript
           const map = new Map();
           const objKey = {};
           map.set(objKey, "value"); // 键为对象
           console.log(map.get(objKey)); // value

           const obj = {};
           obj[objKey] = "value";
           console.log(obj["[object Object]"]); // 'value'（键被转换为字符串）
           ```

        2. 键的顺序性

           - Map：严格按照插入顺序保留键值对的顺序
           - ES6 后部分保留插入顺序，但数字键会按升序排列，其他键按插入顺序，整体顺序不绝对可靠。

        3. 原型污染

           - Map：无原型链继承的键，避免键冲突（如 constructor）。
           - 普通对象：可能继承原型上的键（如 obj.constructor 存在默认值）。

        4. 迭代方式

           - Map：直接通过 for...of 或 forEach 迭代键值对。
           - 普通对象：需先获取键数组（如 Object.keys(obj)）再迭代。

        5. 序列化支持

           - 普通对象支持 JSON.stringify(), Map 序列化后是 '{}'

        6. 性能优化
           - Map：在频繁增删键值对的场景下性能更优（如哈希表结构优化）。
           - 普通对象：未针对动态操作优化，适合静态数据存储。

## React

1. 自定义 Hooks 与函数式组件的联系与区别？
   **核心关联：**

   1. 函数式编程基础：
      两者都是 JavaScript 函数，遵循函数式编程原则。函数组件负责 UI 渲染，自定义 Hook 负责封装可复用的状态逻辑
   2. Hooks 的共享:
      自定义 Hook 内部会使用 React 内置 Hooks（如 useState、 useEffect 等），而函数组件通过调用自定义 hook 来复用这些逻辑，形成逻辑与 UI 分离的架构
   3. 状态与 UI 的协作：
      函数组件通过调用自定义 Hook 获取状态或方法，并将这些数据映射到 JSX 中，实现动态交互。

   ***

   **核心区别**：

   | **特性**           | **函数组件**                  | **自定义 Hook**                       |
   | ------------------ | ----------------------------- | ------------------------------------- |
   | **职责**           | 定义 UI 结构（返回 JSX）      | 封装可复用的逻辑（返回状态/方法等）   |
   | **命名规则**       | 首字母大写（如`MyComponent`） | 以`use`开头（如`useFetch`）           |
   | **直接使用 Hooks** | 是（如直接调用`useState`）    | 是（可组合内置或其他自定义 Hooks）    |
   | **返回值**         | JSX 元素                      | 任意数据（状态、函数、对象等）        |
   | **调用场景**       | 在 React 渲染过程中被调用     | 在函数组件或其他自定义 Hooks 内部调用 |
